## 词典ADT

### Entry结构

```c++
template <typename K, typename V> struct Entry { //词条模板类
   K key; V value; //关键码、数值
   Entry ( K k = K(), V v = V() ) : key ( k ), value ( v ) {}; //默认构造函数
   Entry ( Entry<K, V> const& e ) : key ( e.key ), value ( e.value ) {}; //基于克隆的构造函数
   bool operator< ( Entry<K, V> const& e ) { return key <  e.key; }  //比较器：小于
   bool operator> ( Entry<K, V> const& e ) { return key >  e.key; }  //比较器：大于
   bool operator== ( Entry<K, V> const& e ) { return key == e.key; } //判等器：等于
   bool operator!= ( Entry<K, V> const& e ) { return key != e.key; } //判等器：不等于
}; //得益于比较器和判等器，从此往后，不必严格区分词条及其对应的关键码
```

### Dictionary结构

```c++
template <typename K, typename V> struct Dictionary { //词典Dictionary模板类
   virtual int size() const = 0; //当前词条总数
   virtual bool put ( K, V ) = 0; //插入词条（禁止雷同词条时可能失败）
   virtual V* get ( K k ) = 0; //读取词条
   virtual bool remove ( K k ) = 0; //删除词条
};
```

### Bitmap结构

```c++
class Bitmap { //位图Bitmap类
private:
   unsigned char* M; int N; //比特图所存放的空间M[]，容量为N*sizeof(char)*8比特
protected:
   void init ( int n ) { M = new unsigned char[N = ( n + 7 ) / 8]; memset ( M, 0, N ); }
public:
   Bitmap ( int n = 8 ) { init ( n ); } //按指定或默认规模创建比特图（为测试暂时选用较小的默认值）
   Bitmap ( char* file, int n = 8 ) //按指定或默认规模，从指定文件中读取比特图
   {  init ( n ); FILE* fp = fopen ( file, "r" ); fread ( M, sizeof ( char ), N, fp ); fclose ( fp );  }
   ~Bitmap() { delete [] M; M = NULL; } //析构时释放比特图空间

   void set   ( int k ) { expand ( k );        M[k >> 3] |=   ( 0x80 >> ( k & 0x07 ) ); }
   void clear ( int k ) { expand ( k );        M[k >> 3] &= ~ ( 0x80 >> ( k & 0x07 ) ); }
   bool test  ( int k ) { expand ( k ); return M[k >> 3] &    ( 0x80 >> ( k & 0x07 ) ); }

   void dump ( char* file ) //将位图整体导出至指定的文件，以便对此后的新位图批量初始化
   {  FILE* fp = fopen ( file, "w" ); fwrite ( M, sizeof ( char ), N, fp ); fclose ( fp );  }
   char* bits2string ( int n ) { //将前n位转换为字符串——
      expand ( n - 1 ); //此时可能被访问的最高位为bitmap[n - 1]
      char* s = new char[n + 1]; s[n] = '\0'; //字符串所占空间，由上层调用者负责释放
      for ( int i = 0; i < n; i++ ) s[i] = test ( i ) ? '1' : '0';
      return s; //返回字符串位置
   }
   void expand ( int k ) { //若被访问的Bitmap[k]已出界，则需扩容
      if ( k < 8 * N ) return; //仍在界内，无需扩容
      int oldN = N; unsigned char* oldM = M;
      init ( 2 * k ); //与向量类似，加倍策略
      memcpy_s ( M, N, oldM, oldN ); delete [] oldM; //原数据转移至新空间
   }
   void print ( int n ) //逐位打印以检验位图内容，非必需接口
   {  expand ( n ); for ( int i = 0; i < n; i++ ) printf ( test ( i ) ? "1" : "0" );  }
};
```

### HashTable结构

```c++
#include "Dictionary/Dictionary.h" //引入词典ADT
#include "Bitmap/Bitmap.h" //引入位图

template <typename K, typename V> //key、value
class Hashtable : public Dictionary<K, V> { //符合Dictionary接口的Hashtable模板类
   friend class UniPrint;
private:
   Entry<K, V>** ht; //桶数组，存放词条指针
   int M, N, L; //桶的总数、词条的数目、懒惰删除标记的数目（N + L <= M）
   Bitmap* removed; //懒惰删除标记
protected:
   int probe4Hit ( const K& k ); //沿关键码k对应的试探链，找到词条匹配的桶
   int probe4Free ( const K& k ); //沿关键码k对应的试探链，找到首个可用空桶
   void rehash(); //重散列算法：扩充桶数组，保证装填因子在警戒线以下
public:
   Hashtable ( int c = 5 ); //创建一个容量不小于c的散列表（为测试暂时选用较小的默认值）
   ~Hashtable(); //释放桶数组及其中各（非空）元素所指向的词条
   int size() const { return N; } // 当前的词条数目
   bool put ( K, V ); //插入（禁止雷同词条，故可能失败）
   V* get ( K k ); //读取
   bool remove ( K k ); //删除
};
```

## 散列表

### Hashtable构造函数

```c++
template <typename K, typename V> Hashtable<K, V>::Hashtable ( int c ) { //创建散列表，容量为
   M = primeNLT ( c, 1048576, "../../_input/prime-1048576-bitmap.txt" ); //不小于c的素数M
   N = 0; ht = new Entry<K, V>*[M]; //开辟桶数组（假定成功）
   memset ( ht, 0, sizeof ( Entry<K, V>* ) * M ); //初始化各桶
   removed = new Bitmap ( M ); L = 0; //用Bitmap记录懒惰删除
   //*DSA*/printf("A bucket array has been created with capacity = %d\n\n", M);
}
```

### Hashtable析构函数

```c++
template <typename K, typename V> Hashtable<K, V>::~Hashtable() { //析构前释放桶数组及非空词条
   for ( int i = 0; i < M; i++ ) //逐一检查各桶
      if ( ht[i] ) release ( ht[i] ); //释放非空的桶
   release ( ht ); //释放桶数组
   release ( removed ); //释放懒惰删除标记
} //release()负责释放复杂结构，与算法无直接关系，具体实现详见代码包
```

### probe4Hit算法

```c++
/******************************************************************************************
 * 沿关键码k的试探链，找到与之匹配的桶；实践中有多种试探策略可选，这里仅以线性试探为例
 ******************************************************************************************/
template <typename K, typename V> int Hashtable<K, V>::probe4Hit ( const K& k ) {
   int r = hashCode( k ) % M; //按除余法确定试探链起点
   while ( ( ht[r] && ( k != ht[r]->key ) ) || removed->test(r) )
      r = ( r + 1 ) % M; //线性试探（跳过带懒惰删除标记的桶）
   return r; //调用者根据ht[r]是否为空及其内容，即可判断查找是否成功
}
```

### probe4Free算法

```c++
/******************************************************************************************
 * 沿关键码k的试探链，找到首个可用空桶；实践中有多种试探策略可选，这里仅以线性试探为例
 ******************************************************************************************/
template <typename K, typename V> int Hashtable<K, V>::probe4Free ( const K& k ) {
   int r = hashCode ( k ) % M; //按除余法确定试探链起点
   while ( ht[r] ) r = ( r + 1 ) % M; //线性试探，直到首个空桶（无论是否带有懒惰删除标记）
   return r; //只要有空桶，线性试探迟早能找到
}
```

### rehash算法

```c++
/******************************************************************************************
 * 重散列：空桶太少时对散列表重新整理：扩容，再将词条逐一移入新表
 * 散列函数的定址与表长M直接相关，故不可简单地批量复制原桶数组
 ******************************************************************************************/
template <typename K, typename V> void Hashtable<K, V>::rehash() {
   int oldM = M; Entry<K, V>** oldHt = ht;
   M = primeNLT( 4 * N, 1048576, PRIME_TABLE ); //容量至少加倍（若懒惰删除很多，可能反而缩容）
   ht = new Entry<K, V>*[M]; N = 0; memset( ht, 0, sizeof( Entry<K, V>* ) * M ); //桶数组
   release( removed ); removed = new Bitmap( M ); L = 0; //懒惰删除标记
   //*DSA*/printf("A bucket array has been created with capacity = %d\n\n", M);
   for ( int i = 0; i < oldM; i++ ) //扫描原表
      if ( oldHt[i] ) //将每个非空桶中的词条
         put( oldHt[i]->key, oldHt[i]->value ); //转入新表
   release( oldHt ); //释放——因所有词条均已转移，故只需释放桶数组本身
}
```

### put方法

```c++
template <typename K, typename V> bool Hashtable<K, V>::put( K k, V v ) { //散列表词条插入
   if ( ht[ probe4Hit( k ) ] ) return false; //雷同元素不必重复插入
   int r = probe4Free( k ); //为新词条找个空桶（只要装填因子控制得当，必然成功）
   ht[ r ] = new Entry<K, V>( k, v ); ++N; //插入
   if ( removed->test( r ) ) { removed->clear( r ); --L; } //懒惰删除标记
   if ( (N + L)*2 > M ) rehash(); //若装填因子高于50%，重散列
   return true;
}
```

### get方法

```c++
template <typename K, typename V> V* Hashtable<K, V>::get ( K k ) //散列表词条查找算法
{  int r = probe4Hit ( k ); return ht[r] ? &( ht[r]->value ) : NULL;  } //禁止词条的key值雷同
```

### remove方法

```c++
template <typename K, typename V> bool Hashtable<K, V>::remove ( K k ) { //散列表词条删除算法
   int r = probe4Hit( k ); if ( !ht[r] ) return false; //确认目标词条确实存在
   release ( ht[r] ); ht[r] = NULL; //清除目标词条
   removed->set(r); --N; ++L; //更新标记、计数器
   if ( 3*N < L ) rehash(); //若懒惰删除标记过多，重散列
   return true;
}
```

## 跳转表

![image-20220823123315729](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220823123315729.png)

#### QuadlistNode

```c++
#include "Entry/Entry.h"
template <typename T> struct QuadlistNode;
template <typename T> using QListNodePosi = QuadlistNode<T>*; //跳转表节点位置
template <typename T> struct QuadlistNode { //QuadlistNode模板类
   T entry; //所存词条
   QListNodePosi<T> pred;  QListNodePosi<T> succ; //前驱、后继
   QListNodePosi<T> above; QListNodePosi<T> below; //上邻、下邻
   QuadlistNode //构造器
   ( T e = T(), QListNodePosi<T> p = NULL, QListNodePosi<T> s = NULL,
     QListNodePosi<T> a = NULL, QListNodePosi<T> b = NULL )
      : entry ( e ), pred ( p ), succ ( s ), above ( a ), below ( b ) {}
   QListNodePosi<T> insertAsSuccAbove //插入新节点，以当前节点为前驱，以节点b为下邻
   ( T const& e, QListNodePosi<T> b = NULL );
};

template <typename T> QListNodePosi<T> //将e作为当前节点的后继、b的上邻插入Quadlist
QuadlistNode<T>::insertAsSuccAbove ( T const& e, QListNodePosi<T> b ) {
   QListNodePosi<T> x = new QuadlistNode<T> ( e, this, succ, NULL, b ); //创建新节点
   succ->pred = x; succ = x; //设置水平逆向链接
   if ( b ) b->above = x; //设置垂直逆向链接
   return x; //返回新节点的位置
}
```

#### Quadlist

```c++
#include "QuadlistNode.h" //引入Quadlist节点类
template <typename T> class Quadlist { //Quadlist模板类
private:
   int _size; QListNodePosi<T> header, trailer; //规模、头哨兵、尾哨兵
protected:
   void init(); //Quadlist创建时的初始化
   int clear(); //清除所有节点
public:
// 构造函数
   Quadlist() { init(); } //默认
// 析构函数
   ~Quadlist() { clear(); delete header; delete trailer; } //删除所有节点，释放哨兵
// 只读访问接口
   Rank size() const { return _size; } //规模
   bool empty() const { return _size <= 0; } //判空
   QListNodePosi<T> first() const { return header->succ; } //首节点位置
   QListNodePosi<T> last() const { return trailer->pred; } //末节点位置
   bool valid ( QListNodePosi<T> p ) //判断位置p是否对外合法
   { return p && ( trailer != p ) && ( header != p ); }
// 可写访问接口
   T remove ( QListNodePosi<T> p ); //删除（合法）位置p处的节点，返回被删除节点的数值
   QListNodePosi<T> //将*e作为p的后继、b的上邻插入
   insertAfterAbove ( T const& e, QListNodePosi<T> p, QListNodePosi<T> b = NULL );
// 遍历
   void traverse ( void (* ) ( T& ) ); //遍历各节点，依次实施指定操作（函数指针，只读或局部修改）
   template <typename VST> //操作器
   void traverse ( VST& ); //遍历各节点，依次实施指定操作（函数对象，可全局性修改节点）
}; //Quadlist

template <typename T> QListNodePosi<T> //将e作为p的后继、b的上邻插入Quadlist
Quadlist<T>::insertAfterAbove ( T const& e, QListNodePosi<T> p, QListNodePosi<T> b )
{  _size++; return p->insertAsSuccAbove ( e, b );  } //返回新节点位置（below = NULL）

template <typename T> //删除Quadlist内位置p处的节点，返回其中存放的词条
T Quadlist<T>::remove ( QListNodePosi<T> p ) { //assert: p为Quadlist中的合法位置
   p->pred->succ = p->succ; p->succ->pred = p->pred; _size--;//摘除节点
   T e = p->entry; delete p; //备份词条，释放节点
   return e; //返回词条
}

template <typename T> void Quadlist<T>::init() { //Quadlist初始化，创建Quadlist对象时统一调用
   header = new QuadlistNode<T>; //创建头哨兵节点
   trailer = new QuadlistNode<T>; //创建尾哨兵节点
   header->succ = trailer; header->pred = NULL; //沿横向联接哨兵
   trailer->pred = header; trailer->succ = NULL; //沿横向联接哨兵
   header->above = trailer->above = NULL; //纵向的后继置空
   header->below = trailer->below = NULL; //纵向的前驱置空
   _size = 0; //记录规模
} //如此构造的四联表，不含任何实质的节点，且暂时与其它四联表相互独立

template <typename T> int Quadlist<T>::clear() { //清空Quadlist
   int oldSize = _size;
   while ( 0 < _size ) remove ( header->succ ); //逐个删除所有节点
   return oldSize;
}
```

#### SkipList

```c++
#include "List/List.h" //引入列表
#include "Entry/Entry.h" //引入词条
#include "Quadlist.h" //引入Quadlist
#include "Dictionary/Dictionary.h" //引入词典

template <typename K, typename V> //key、value
//符合Dictionary接口的Skiplist模板类（但隐含假设元素之间可比较大小）
class Skiplist : public Dictionary<K, V>, public List<Quadlist<Entry<K, V>>*> {
protected:
   bool skipSearch (
      ListNode<Quadlist<Entry<K, V>>*>* &qlist,
      QuadlistNode<Entry<K, V>>* &p,
      K& k );
public:
   int size() const { return empty() ? 0 : last()->data->size(); } //底层Quadlist的规模
   int level() { return List::size(); } //层高 == #Quadlist，不一定要开放
   bool put ( K, V ); //插入（注意与Map有别——Skiplist允许词条重复，故必然成功）
   V* get ( K k ); //读取
   bool remove ( K k ); //删除
};
```

#### 查找算法

```c++
template <typename K, typename V> V* Skiplist<K, V>::get ( K k ) { //跳转表词条查找算法
   if ( empty() ) return NULL;
   ListNode<Quadlist<Entry<K, V>>*>* qlist = first(); //从顶层Quadlist的
   QuadlistNode<Entry<K, V>>* p = qlist->data->first(); //首节点开始
   return skipSearch ( qlist, p, k ) ? & ( p->entry.value ) : NULL; //查找并报告
} //有多个命中时靠后者优先

/******************************************************************************************
 * Skiplist词条查找算法（供内部调用）
 * 入口：qlist为顶层列表，p为qlist的首节点
 * 出口：若成功，p为命中关键码所属塔的顶部节点，qlist为p所属列表
 *       否则，p为所属塔的基座，该塔对应于不大于k的最大且最靠右关键码，qlist为空
 * 约定：多个词条命中时，沿四联表取最靠后者
 ******************************************************************************************/
template <typename K, typename V> bool Skiplist<K, V>::skipSearch (
   ListNode<Quadlist<Entry<K, V>>*>* &qlist, //从指定层qlist的
   QuadlistNode<Entry<K, V>>* &p, //首节点p出发
   K& k ) { //向右、向下查找目标关键码k
   while ( true ) { //在每一层
      while ( p->succ && ( p->entry.key <= k ) ) //从前向后查找
         p = p->succ; //直到出现更大的key或溢出至trailer
      p = p->pred; //此时倒回一步，即可判断是否
      if ( p->pred && ( k == p->entry.key ) ) return true; //命中
      qlist = qlist->succ; //否则转入下一层
      //注意：List有header和trailer
      if ( !qlist->succ ) return false; //若已到穿透底层，则意味着失败
      p = ( p->pred ) ? p->below : qlist->data->first(); //否则转至当前塔的下一节点
   }  //课后：通过实验统计，验证关于平均查找长度的结论
}

```

> 生长概率逐层减半条件：![image-20220823114603348](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220823114603348.png)

#### 插入算法

```c++
template <typename K, typename V> bool Skiplist<K, V>::put ( K k, V v ) { //跳转表词条插入算法
   Entry<K, V> e = Entry<K, V> ( k, v ); //待插入的词条（将被随机地插入多个副本）
   if ( empty() ) insertAsFirst ( new Quadlist<Entry<K, V>> ); //插入首个Entry
   ListNode<Quadlist<Entry<K, V>>*>* qlist = first(); //从顶层四联表的
   QuadlistNode<Entry<K, V>>* p = qlist->data->first(); //首节点出发
   if ( skipSearch ( qlist, p, k ) ) //查找适当的插入位置（不大于关键码k的最后一个节点p）
      while ( p->below ) p = p->below; //若已有雷同词条，则需强制转到塔底
   qlist = last(); //以下，紧邻于p的右侧，一座新塔将自底而上逐层生长
   QuadlistNode<Entry<K, V>>* b = qlist->data->insertAfterAbove ( e, p ); //新节点b即新塔基座
   while ( rand() & 1 ) { //经投掷硬币，若确定新塔需要再长高一层，则
      while ( qlist->data->valid ( p ) && !p->above ) p = p->pred; //找出不低于此高度的最近前驱
      if ( !qlist->data->valid ( p ) ) { //若该前驱是header
         if ( qlist == first() ) //且当前已是最顶层，则意味着必须
            insertAsFirst ( new Quadlist<Entry<K, V>> ); //首先创建新的一层，然后
         p = qlist->pred->data->first()->pred; //将p转至上一层Skiplist的header
      } else //否则，可径自
         p = p->above; //将p提升至该高度
      qlist = qlist->pred; //上升一层，并在该层
      b = qlist->data->insertAfterAbove ( e, p, b ); //将新节点插入p之后、b之上
   }//课后：调整随机参数，观察总体层高的相应变化
   return true; //Dictionary允许重复元素，故插入必成功——这与Hashtable等Map略有差异
}
```

#### 删除算法

```c++
template <typename K, typename V> bool Skiplist<K, V>::remove ( K k ) { //跳转表词条删除算法
   if ( empty() ) return false; //空表情况
   ListNode<Quadlist<Entry<K, V>>*>* qlist = first(); //从顶层Quadlist的
   QuadlistNode<Entry<K, V>>* p = qlist->data->first(); //首节点开始
   if ( !skipSearch ( qlist, p, k ) ) return false; //目标词条不存在，直接返回
   do { //若目标词条存在，则逐层拆除与之对应的塔
      QuadlistNode<Entry<K, V>>* lower = p->below; //记住下一层节点，并
      qlist->data->remove ( p ); //删除当前层节点，再
      p = lower; qlist = qlist->succ; //转入下一层
   } while ( qlist->succ ); //如上不断重复，直到塔基
   while ( !empty() && first()->data->empty() ) //逐一地
      List::remove ( first() ); //清除已可能不含词条的顶层Quadlist
   return true; //删除操作成功完成
}
```



