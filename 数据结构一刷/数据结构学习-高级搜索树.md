## 伸展树：逐层伸展

### 局部性

Locality:刚被访问过的数据，极有可能很快地再次被访问，这一现象在信息处理过程中屡见不鲜。

> 连续的m次查询（m>>n = |BST|），采用AVL需要O(m*logn)时间，利用局部性原理，效仿自适应链表，节点一旦被访问，随即调整至树根。

### 逐层伸展

自下而上，逐层伸展：zig(v->parent)、zag(v->parent)直至v被推送至根。

### 最坏情况

- 全树拓扑始终呈单链条结构，等价于一维列表。
- 被访问的节点的深度，呈周期性的算术级别演进，平均为O(n)：n-1 n-2 n-3 ... 1![image-20220815205245462](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220815205245462.png)

## 伸展树：双层伸展

==精髓：向上追溯两层，而非一层，自上而下进行旋转。==

:factory:平凡情况：

![image-20220815214740487](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220815214740487.png)

:rocket:点睛之笔：

![image-20220815214755020](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220815214755020.png)

:boat:效果展示：

![image-20220815214827249](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220815214827249.png)

:cactus:特殊情况：

![image-20220815214858019](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220815214858019.png)

## 伸展树：算法实现

```c++
#include "BST/BST.h" //基于BST实现Splay
template <typename T> class Splay : public BST<T> { //由BST派生的Splay树模板类
protected:
   BinNodePosi<T> splay ( BinNodePosi<T> v ); //将节点v伸展至根
public:
   BinNodePosi<T> & search ( const T& e ); //查找（重写）
   BinNodePosi<T> insert ( const T& e ); //插入（重写）
   bool remove ( const T& e ); //删除（重写）
```

### 伸展算法

![image-20220815220252060](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220815220252060.png)

```c++
template <typename NodePosi> inline //在节点*p与*lc（可能为空）之间建立父（左）子关系
void attachAsLC ( NodePosi lc, NodePosi p ) { p->lc = lc; if ( lc ) lc->parent = p; }

template <typename NodePosi> inline //在节点*p与*rc（可能为空）之间建立父（右）子关系
void attachAsRC ( NodePosi p, NodePosi rc ) { p->rc = rc; if ( rc ) rc->parent = p; }

template <typename T> //Splay树伸展算法：从节点v出发逐层伸展
BinNodePosi<T> Splay<T>::splay ( BinNodePosi<T> v ) { //v为因最近访问而需伸展的节点位置
   if ( !v ) return NULL; BinNodePosi<T> p; BinNodePosi<T> g; //*v的父亲与祖父
   while ( ( p = v->parent ) && ( g = p->parent ) ) { //自下而上，反复对*v做双层伸展
      BinNodePosi<T> gg = g->parent; //每轮之后*v都以原曾祖父（great-grand parent）为父
      if ( IsLChild ( *v ) )
         if ( IsLChild ( *p ) ) { //zig-zig
            printf ( "\tzIg-zIg :" ); print ( g ); print ( p ); print ( v ); printf ( "\n" );
            attachAsLC ( p->rc, g ); 
            attachAsLC ( v->rc, p );
            attachAsRC ( p, g ); 
            attachAsRC ( v, p );
         } else { //zig-zag
            printf ( "\tzIg-zAg :" ); print ( g ); print ( p ); print ( v ); printf ( "\n" );
            attachAsLC ( v->rc, p ); 
            attachAsRC ( g, v->lc );
            attachAsLC ( g, v ); 
            attachAsRC ( v, p );
         }
      else if ( IsRChild ( *p ) ) { //zag-zag
         printf ( "\tzAg-zAg :" ); print ( g ); print ( p ); print ( v ); printf ( "\n" );
         attachAsRC ( g, p->lc ); 
         attachAsRC ( p, v->lc );
         attachAsLC ( g, p ); 
         attachAsLC ( p, v );
      } else { //zag-zig
         printf ( "\tzAg-zIg :" ); print ( g ); print ( p ); print ( v ); printf ( "\n" );
         attachAsRC ( p, v->lc ); 
         attachAsLC ( v->rc, g );
         attachAsRC ( v, g );
         attachAsLC ( p, v );
      }
      if ( !gg ) v->parent = NULL; //若*v原先的曾祖父*gg不存在，则*v现在应为树根
      else //否则，*gg此后应该以*v作为左或右孩子
         ( g == gg->lc ) ? attachAsLC ( v, gg ) : attachAsRC ( gg, v );
      updateHeight ( g ); updateHeight ( p ); updateHeight ( v );
   } //双层伸展结束时，必有g == NULL，但p可能非空
   if ( p = v->parent ) { //若p果真非空，则额外再做一次单旋
      if ( IsLChild ( *v ) ) { printf ( "\tzIg :" ); print ( p ); print ( v ); printf ( "\n" ); }
      else { printf ( "\tzAg :" ); print ( p ); print ( v ); printf ( "\n" ); }
      if ( IsLChild ( *v ) ) { attachAsLC ( v->rc, p ); attachAsRC ( v, p ); }
      else { attachAsRC ( p, v->lc ); attachAsLC ( p, v ); }
      updateHeight ( p ); updateHeight ( v );
   }
   v->parent = NULL; return v;
} //调整之后新树根应为被伸展的节点，故返回该节点的位置以便上层函数更新树根
```

### 查找算法

```c++
template <typename T> BinNodePosi<T> & Splay<T>::search ( const T & e ) { //在伸展树中查找e
   BinNodePosi<T> p = BST<T>::search ( e );
   _root = splay ( p ? p : _hot ); //将最后一个被访问的节点伸展至根
   return _root;
} //与其它BST不同，无论查找成功与否，_root都指向最后被访问的节点
```

### 插入算法

![image-20220815235442363](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220815235442363.png)

```c++
template <typename T> BinNodePosi<T> Splay<T>::insert ( const T& e ) { //将关键码e插入伸展树中
   if ( !_root ) { _size = 1; return _root = new BinNode<T> ( e ); } //原树为空
   BinNodePosi<T> t = search( e ); if ( e == t->data ) return t; //目标节点t若存在，伸展至根
   if ( t->data < e ) { //在右侧嫁接
      t->parent = _root = new BinNode<T> ( e, NULL, t, t->rc ); //lc == t必非空
      if ( t->rc ) { t->rc->parent = _root; t->rc = NULL; } //rc或为空
   } else { //在左侧嫁接
      t->parent = _root = new BinNode<T> ( e, NULL, t->lc, t ); //rc == t必非空
      if ( t->lc ) { t->lc->parent = _root; t->lc = NULL; } //lc或为空
   }
   _size++; updateHeightAbove ( t ); return _root; //更新规模及高度，报告插入成功
} //无论e是否存在于原树中，返回时总有_root->data == e
```

### 删除操作

![image-20220815235851630](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220815235851630.png)

```c++
template <typename T> bool Splay<T>::remove ( const T& e ) { //从伸展树中删除关键码e
   if ( !_root || ( e != search ( e )->data ) ) return false; //若目标存在，则伸展至根
   BinNodePosi<T> L = _root->lc, R = _root->rc; release(_root); //记下左、右子树L、R后，释放之
   if ( !R ) { //若R空，则
      if ( L ) L->parent = NULL; _root = L; //L即是余树
   } else { //否则
      _root = R; R->parent = NULL; search( e ); //在R中再次查找e：注定失败，但其中的最小节点必
      if (L) L->parent = _root; _root->lc = L; //伸展至根（且无左孩子），故可令其以L作为左子树
   }
   if ( --_size ) updateHeight ( _root ); return true; //更新规模及树高，报告删除成功
}
```

![image-20220816000412913](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220816000412913.png)

## B-树：结构

B-树逻辑上与BBST完全等价，是一种平衡的多路搜索树。然而，引入B-树有其特殊的作用：

![image-20220819160953334](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220819160953334.png)

### B-树的定义

![image-20220819161228684](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220819161228684.png)

![image-20220819161402001](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220819161402001.png)

### BTNode结构

```c++
template <typename T> struct BTNode;
template <typename T> using BTNodePosi = BTNode<T>*; //B-树节点位置

template <typename T> struct BTNode { //B-树节点模板类
// 成员（为简化描述起见统一开放，读者可根据需要进一步封装）
   BTNodePosi<T> parent; //父节点
   Vector<T> key; //关键码向量
   Vector<BTNodePosi<T>> child; //孩子向量（总比关键码多一个）
// 构造函数
   BTNode() { parent = NULL; child.insert ( NULL ); } //无关键码节点
   BTNode ( T e, BTNodePosi<T> lc = NULL, BTNodePosi<T> rc = NULL ) {
      parent = NULL; key.insert ( e ); //作为根节点只有一个关键码，以及
      child.insert ( lc ); if ( lc ) lc->parent = this; //左孩子
      child.insert ( rc ); if ( rc ) rc->parent = this; //右孩子
   }
};
```

### BTree结构

```c++
#include "BTNode.h" //引入B-树节点类

template <typename T> class BTree { //B-树模板类
protected:
   int _size; //存放的关键码总数
   int _m; //B-树的阶次，至少为3——创建时指定，一般不能修改
   BTNodePosi<T> _root; //根节点
   BTNodePosi<T> _hot; //BTree::search()最后访问的非空（除非树空）的节点位置
   void solveOverflow ( BTNodePosi<T> ); //因插入而上溢之后的分裂处理
   void solveUnderflow ( BTNodePosi<T> ); //因删除而下溢之后的合并处理
public:
   BTree ( int m = 3 ) : _m ( m ), _size ( 0 ) //构造函数：默认为最低的3阶
   { _root = new BTNode<T>(); }
   ~BTree() { if ( _root ) release ( _root ); } //析构函数：释放所有节点
   int const order() { return _m; } //阶次
   int const size() { return _size; } //规模
   BTNodePosi<T> & root() { return _root; } //树根
   bool empty() const { return !_root; } //判空
   BTNodePosi<T> search ( const T& e ); //查找
   bool insert ( const T& e ); //插入
   bool remove ( const T& e ); //删除
}; //BTree
```

## B-树：查找

```c++
template <typename T> BTNodePosi<T> BTree<T>::search ( const T& e ) { //在B-树中查找关键码e
   BTNodePosi<T> v = _root; _hot = NULL; //从根节点出发
   while ( v ) { //逐层查找
      Rank r = v->key.search ( e ); //在当前节点中，找到不大于e的最大关键码
      if ( ( 0 <= r ) && ( e == v->key[r] ) ) return v; //成功：在当前节点中命中目标关键码
      _hot = v; v = v->child[r + 1]; //否则，转入对应子树（_hot指向其父）——需做I/O，最费时间
   } //这里在向量内是二分查找，但对通常的_m可直接顺序查找
   return NULL; //失败：最终抵达外部节点
}
```

### 复杂度

![image-20220819165141476](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220819165141476.png)

### 最大树高

![image-20220819165442271](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220819165442271.png)

### 最小树高

![image-20220819165516904](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220819165516904.png)

## B-树：插入

```c++
template <typename T> bool BTree<T>::insert ( const T& e ) { //将关键码e插入B树中
   BTNodePosi<T> v = search ( e ); if ( v ) return false; //确认目标节点不存在
   Rank r = _hot->key.search ( e ); //在节点_hot的有序关键码向量中查找合适的插入位置
   _hot->key.insert ( r + 1, e ); //将新关键码插至对应的位置
   _hot->child.insert ( r + 2, NULL ); //创建一个空子树指针
   _size++; //更新全树规模
   solveOverflow ( _hot ); //如有必要，需做分裂
   return true; //插入成功
}


template <typename T> //关键码插入后若节点上溢，则做节点分裂处理
void BTree<T>::solveOverflow ( BTNodePosi<T> v ) {
   if ( _m > v->key.size() ) return; //递归基：当前节点并未上溢;m阶B-树的节点分支数目最大m，节点key值数目最大m-1
   Rank s = _m / 2; //轴点（此时应有_m = key.size() = child.size() - 1）
   BTNodePosi<T> u = new BTNode<T>(); //注意：新节点已有一个空孩子
   for ( Rank j = 0; j < _m - s - 1; j++ ) { //v右侧_m-s-1个孩子及关键码分裂为右侧节点u
      u->child.insert ( j, v->child.remove ( s + 1 ) ); //逐个移动效率低
      u->key.insert ( j, v->key.remove ( s + 1 ) ); //此策略可改进
   }
   u->child[_m - s - 1] = v->child.remove ( s + 1 ); //移动v最靠右的孩子
   if ( u->child[0] ) //若u的孩子们非空（即当前发送分裂的节点不是叶子节点），则
      for ( Rank j = 0; j < _m - s; j++ ) //令它们的父节点统一
         u->child[j]->parent = u; //指向u
   BTNodePosi<T> p = v->parent; //v当前的父节点p
   if ( !p ) { _root = p = new BTNode<T>(); p->child[0] = v; v->parent = p; } //若p空则创建之
   Rank r = 1 + p->key.search ( v->key[0] ); //p中指向v的指针的秩
   p->key.insert ( r, v->key.remove ( s ) ); //轴点关键码上升
   p->child.insert ( r + 1, u );  u->parent = p; //新节点u与父节点p互联
   solveOverflow ( p ); //上升一层，如有必要则继续分裂——至多递归O(logn)层
}
```

## B-树：删除

```c++
template <typename T> bool BTree<T>::remove ( const T& e ) { //从BTree树中删除关键码e
   BTNodePosi<T> v = search ( e ); if ( !v ) return false; //确认目标关键码存在
   Rank r = v->key.search ( e ); //确定目标关键码在节点v中的秩（由上，肯定合法）
   if ( v->child[0] ) { //若v非叶子，则e的后继必属于某叶节点
      BTNodePosi<T> u = v->child[r+1]; //在右子树中一直向左，即可
      while ( u->child[0] ) u = u->child[0]; //找出e的后继
      v->key[r] = u->key[0]; v = u; r = 0; //并与之交换位置
   } //至此，v必然位于最底层，且其中第r个关键码就是待删除者
   v->key.remove ( r ); v->child.remove ( r + 1 ); _size--; //删除e，以及其下两个外部节点之一
   solveUnderflow ( v ); //如有必要，需做旋转或合并
   return true;
}


template <typename T> //关键码删除后若节点下溢，则做节点旋转或合并处理
void BTree<T>::solveUnderflow ( BTNodePosi<T> v ) {
   if ( ( _m + 1 ) / 2 <= v->child.size() ) return; //递归基：当前节点并未下溢
   BTNodePosi<T> p = v->parent;
   if ( !p ) { //递归基：已到根节点，没有孩子的下限
      if ( !v->key.size() && v->child[0] ) {
         //但倘若作为树根的v已不含关键码，却有（唯一的）非空孩子，则
         /*DSA*/printf ( "collapse\n" );
         _root = v->child[0]; _root->parent = NULL; //这个节点可被跳过
         v->child[0] = NULL; release ( v ); //并因不再有用而被销毁
      } //整树高度降低一层
      return;
   }
   Rank r = 0; while ( p->child[r] != v ) r++;
   //确定v是p的第r个孩子——此时v可能不含关键码，故不能通过关键码查找
   //另外，在实现了孩子指针的判等器之后，也可直接调用Vector::find()定位
   /*DSA*/printf ( "\nrank = %d", r );
// 情况1：向左兄弟借关键码
   if ( 0 < r ) { //若v不是p的第一个孩子，则
      BTNodePosi<T> ls = p->child[r - 1]; //左兄弟必存在
      if ( ( _m + 1 ) / 2 < ls->child.size() ) { //若该兄弟足够“胖”，则
         /*DSA*/printf ( " ... case 1\n" );
         v->key.insert ( 0, p->key[r - 1] ); //p借出一个关键码给v（作为最小关键码）
         p->key[r - 1] = ls->key.remove ( ls->key.size() - 1 ); //ls的最大关键码转入p
         v->child.insert ( 0, ls->child.remove ( ls->child.size() - 1 ) );
         //同时ls的最右侧孩子过继给v
         if ( v->child[0] ) v->child[0]->parent = v; //作为v的最左侧孩子
         return; //至此，通过右旋已完成当前层（以及所有层）的下溢处理
      }
   } //至此，左兄弟要么为空，要么太“瘦”
// 情况2：向右兄弟借关键码
   if ( p->child.size() - 1 > r ) { //若v不是p的最后一个孩子，则
      BTNodePosi<T> rs = p->child[r + 1]; //右兄弟必存在
      if ( ( _m + 1 ) / 2 < rs->child.size() ) { //若该兄弟足够“胖”，则
         /*DSA*/printf ( " ... case 2\n" );
         v->key.insert ( v->key.size(), p->key[r] ); //p借出一个关键码给v（作为最大关键码）
         p->key[r] = rs->key.remove ( 0 ); //rs的最小关键码转入p
         v->child.insert ( v->child.size(), rs->child.remove ( 0 ) );
         //同时rs的最左侧孩子过继给v
         if ( v->child[v->child.size() - 1] ) //作为v的最右侧孩子
            v->child[v->child.size() - 1]->parent = v;
         return; //至此，通过左旋已完成当前层（以及所有层）的下溢处理
      }
   } //至此，右兄弟要么为空，要么太“瘦”
// 情况3：左、右兄弟要么为空（但不可能同时），要么都太“瘦”——合并
   if ( 0 < r ) { //与左兄弟合并
      /*DSA*/printf ( " ... case 3L\n" );
      BTNodePosi<T> ls = p->child[r - 1]; //左兄弟必存在
      ls->key.insert ( ls->key.size(), p->key.remove ( r - 1 ) ); p->child.remove ( r );
      //p的第r - 1个关键码转入ls，v不再是p的第r个孩子
      ls->child.insert ( ls->child.size(), v->child.remove ( 0 ) );
      if ( ls->child[ls->child.size() - 1] ) //v的最左侧孩子过继给ls做最右侧孩子
         ls->child[ls->child.size() - 1]->parent = ls;
      while ( !v->key.empty() ) { //v剩余的关键码和孩子，依次转入ls
         ls->key.insert ( ls->key.size(), v->key.remove ( 0 ) );
         ls->child.insert ( ls->child.size(), v->child.remove ( 0 ) );
         if ( ls->child[ls->child.size() - 1] ) ls->child[ls->child.size() - 1]->parent = ls;
      }
      release ( v ); //释放v
   } else { //与右兄弟合并
      /*DSA*/printf ( " ... case 3R\n" );
      BTNodePosi<T> rs = p->child[r + 1]; //右兄弟必存在
      rs->key.insert ( 0, p->key.remove ( r ) ); p->child.remove ( r );
      //p的第r个关键码转入rs，v不再是p的第r个孩子
      rs->child.insert ( 0, v->child.remove ( v->child.size() - 1 ) );
      if ( rs->child[0] ) rs->child[0]->parent = rs; //v的最右侧孩子过继给rs做最左侧孩子
      while ( !v->key.empty() ) { //v剩余的关键码和孩子，依次转入rs
         rs->key.insert ( 0, v->key.remove ( v->key.size() - 1 ) );
         rs->child.insert ( 0, v->child.remove ( v->child.size() - 1 ) );
         if ( rs->child[0] ) rs->child[0]->parent = rs;
      }
      release ( v ); //释放v
   }
   solveUnderflow ( p ); //上升一层，如有必要则继续分裂——至多递归O(logn)层
   return;
}
```

## 红黑树:结构

红黑树的定义：由红、黑两类节点组成的BST（统一增设外部节点NULL，使之成为真二叉树），满足以下条件：

1. 树根：必为黑色
2. 外部节点：均为黑色
3. 其余节点：若为红色，只能有黑孩子
4. 外部节点到根：途中黑节点数目相等

> 红黑树==（2，4）树：提升各个红节点，使之与其黑父亲等高，于是每颗红黑树，都对应一颗（2，4）树

![image-20220822180654409](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220822180654409.png)

```c++
#define IsBlack(p) ( ! (p) || ( RB_BLACK == (p)->color ) ) //外部节点也视作黑节点
#define IsRed(p) ( ! IsBlack(p) ) //非黑即红
#define BlackHeightUpdated(x) ( /*RedBlack高度更新条件*/ \
   ( stature( (x).lc ) == stature( (x).rc ) ) && \
   ( (x).height == ( IsRed(& x) ? stature( (x).lc ) : stature( (x).lc ) + 1 ) ) \
)
#define stature(p) ((p) ? (p)->height : 0) //红黑树节点的黑高度（NULL视作外部节点，对应于0）


#include "BST/BST.h" //基于BST实现RedBlack
template <typename T> class RedBlack : public BST<T> { //RedBlack树模板类
protected:
   void solveDoubleRed ( BinNodePosi<T> x ); //双红修正
   void solveDoubleBlack ( BinNodePosi<T> x ); //双黑修正
   int updateHeight ( BinNodePosi<T> x ); //更新节点x的高度（重写）
public:
   BinNodePosi<T> insert ( const T& e ); //插入（重写）
   bool remove ( const T& e ); //删除（重写）
// BST::search()等其余接口可直接沿用
};

template <typename T> int RedBlack<T>::updateHeight ( BinNodePosi<T> x ) { //更新节点高度
   return x->height = IsBlack ( x ) + max ( stature ( x->lc ), stature ( x->rc ) ); //孩子黑高度通常相等，除非出现双黑
   /*DSA*/// 红黑树中各节点左、右孩子的黑高度通常相等
   /*DSA*/// 这里之所以取更大值，是便于在删除节点后的平衡调整过程中，正确更新被删除节点父亲的黑高度
   /*DSA*/// 否则，rotateAt()会根据被删除节点的替代者（高度小一）设置父节点的黑高度
}
```

### 插入算法

- 情况一：![image-20220822191135845](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220822191135845.png)
- 情况一：![image-20220822191241122](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220822191241122.png)
- 情况二：![image-20220822191317684](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220822191317684.png)
- 情况二：![image-20220822191406416](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220822191406416.png)
- 情况二：![image-20220822191452518](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220822191452518.png)

```c++
/******************************************************************************************
 * 与BinNode具有特定关系的节点及指针
 ******************************************************************************************/
#define sibling( p ) ( IsLChild( * (p) ) ? (p)->parent->rc : (p)->parent->lc ) /*兄弟*/
#define uncle( x ) ( sibling( (x)->parent ) ) /*叔叔*/
#define FromParentTo( x ) /*来自父亲的引用*/ \
   ( IsRoot(x) ? _root : ( IsLChild(x) ? (x).parent->lc : (x).parent->rc ) )


template <typename T> BinNodePosi<T> RedBlack<T>::insert ( const T& e ) { //将e插入红黑树
   BinNodePosi<T> & x = search ( e ); if ( x ) return x; //确认目标不存在（留意对_hot的设置）
   x = new BinNode<T> ( e, _hot, NULL, NULL, 0 ); _size++; //创建红节点x：以_hot为父，黑高度0
   BinNodePosi<T> xOld = x; solveDoubleRed ( x ); return xOld; //经双红修正后，即可返回
} //无论e是否存在于原树中，返回时总有x->data == e


/******************************************************************************************
 * RedBlack双红调整算法：解决节点x与其父均为红色的问题。分为两大类情况：
 *    RR-1：2次颜色翻转，2次黑高度更新，1~2次旋转，不再递归
 *    RR-2：3次颜色翻转，3次黑高度更新，0次旋转，需要递归
 ******************************************************************************************/
template <typename T> void RedBlack<T>::solveDoubleRed ( BinNodePosi<T> x ) { //x当前必为红
   if ( IsRoot ( *x ) ) //若已（递归）转至树根，则将其转黑，整树黑高度也随之递增
      {  _root->color = RB_BLACK; _root->height++; return;  } //否则，x的父亲p必存在
   BinNodePosi<T> p = x->parent; if ( IsBlack ( p ) ) return; //若p为黑，则可终止调整。否则
   BinNodePosi<T> g = p->parent; //既然p为红，则x的祖父必存在，且必为黑色
   BinNodePosi<T> u = uncle ( x ); //以下，视x叔父u的颜色分别处理
   if ( IsBlack ( u ) ) { //u为黑色（含NULL）时 //*DSA*/printf("  case RR-1:\n");
      if ( IsLChild ( *x ) == IsLChild ( *p ) ) //若x与p同侧（即zIg-zIg或zAg-zAg），则
         p->color = RB_BLACK; //p由红转黑，x保持红
      else //若x与p异侧（即zIg-zAg或zAg-zIg），则
         x->color = RB_BLACK; //x由红转黑，p保持红
      g->color = RB_RED; //g必定由黑转红
///// 以上虽保证总共两次染色，但因增加了判断而得不偿失
///// 在旋转后将根置黑、孩子置红，虽需三次染色但效率更高
      BinNodePosi<T> gg = g->parent; //曾祖父（great-grand parent）
      BinNodePosi<T> r = FromParentTo ( *g ) = rotateAt ( x ); //调整后的子树根节点
      r->parent = gg; //与原曾祖父联接
   } else { //若u为红色 //*DSA*/printf("  case RR-2:\n");
      p->color = RB_BLACK; p->height++; //p由红转黑
      u->color = RB_BLACK; u->height++; //u由红转黑
      g->color = RB_RED; //g若非根，则转红
      solveDoubleRed ( g ); //继续调整g（类似于尾递归，可优化为迭代形式）
   }
}
```

