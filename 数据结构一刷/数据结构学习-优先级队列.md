## 优先级队列:ADT

#### :boat:应用

- 离散事件模拟
- 操作系统：任务调度、中断处理、GUI中的MRU......
- 输入法：词频调整

#### :factory:算法

> 作为底层数据结构所支持的高效操作，是很多高效算法的基础。

- 内部、外部、在线排序
- 贪心算法：HUffman编码、Prim
- 平面扫描算法中的事件队列

#### :panda_face:特点

- 极值元素：需反复地、快速地定位
- 集合组成：可动态变化
- 元素优先级：可动态变化

```c++
template <typename T> struct PQ { //优先级队列PQ模板类
   virtual void insert ( T ) = 0; //按照比较器确定的优先级次序插入词条
   virtual T getMax() = 0; //取出优先级最高的词条
   virtual T delMax() = 0; //删除优先级最高的词条
};
```

> Stack和Queue都是PQ的特例----优先级完全取决于元素的插入顺序

## 完全二叉堆:ADT

```c++
#define  Parent(i)         ( ( ( i ) - 1 ) >> 1 ) //PQ[i]的父节点（floor((i-1)/2)，i无论正负）
#define  LChild(i)         ( 1 + ( ( i ) << 1 ) ) //PQ[i]的左孩子
#define  RChild(i)         ( ( 1 + ( i ) ) << 1 ) //PQ[i]的右孩子
#define  InHeap(n, i)      ( ( ( -1 ) < ( i ) ) && ( ( i ) < ( n ) ) ) //判断PQ[i]是否合法
#define  LChildValid(n, i) InHeap( n, LChild( i ) ) //判断PQ[i]是否有一个（左）孩子
#define  RChildValid(n, i) InHeap( n, RChild( i ) ) //判断PQ[i]是否有两个孩子
#define  Bigger(PQ, i, j)  ( lt( PQ[i], PQ[j] ) ? j : i ) //取大者（等时前者优先）
#define  ProperParent(PQ, n, i) /*父子（至多）三者中的大者*/ \
            ( RChildValid(n, i) ? Bigger( PQ, Bigger( PQ, i, LChild(i) ), RChild(i) ) : \
            ( LChildValid(n, i) ? Bigger( PQ, i, LChild(i) ) : i \
            ) \
            ) //相等时父节点优先，如此可避免不必要的交换

#include "Vector/Vector.h" //借助多重继承机制，基于向量
#include "PQ/PQ.h" //按照优先级队列ADT实现的
template <typename T> struct PQ_ComplHeap : public PQ<T>, public Vector<T> { //完全二叉堆
   friend class UniPrint; //演示输出使用，否则不必设置友类
   PQ_ComplHeap() { } //默认构造
   PQ_ComplHeap ( T* A, Rank n ) { copyFrom ( A, 0, n ); heapify ( _elem, n ); } //批量构造
   void insert ( T ); //按照比较器确定的优先级次序，插入词条
   T getMax(); //读取优先级最高的词条
   T delMax(); //删除优先级最高的词条
}; //PQ_ComplHeap
template <typename T> void heapify ( T* A, Rank n ); //Floyd建堆算法
template <typename T> Rank percolateDown ( T* A, Rank n, Rank i ); //下滤
template <typename T> Rank percolateUp ( T* A, Rank i ); //上滤
```

### 插入与上滤

```c++
template <typename T> void PQ_ComplHeap<T>::insert ( T e ) { //将词条插入完全二叉堆中
   Vector<T>::insert ( e ); //首先将新词条接至向量末尾
   percolateUp ( _elem, _size - 1 ); //再对该词条实施上滤调整
}

//对向量中的第i个词条实施上滤操作，i < _size
template <typename T> Rank percolateUp ( T* A, Rank i ) {
   while ( 0 < i ) { //在抵达堆顶之前，反复地
      Rank j = Parent ( i ); //考查[i]之父亲[j]
      if ( lt ( A[i], A[j] ) ) break; //一旦父子顺序，上滤旋即完成；否则
      swap ( A[i], A[j] ); i = j; //父子换位，并继续考查上一层
   } //while
   return i; //返回上滤最终抵达的位置
}
```

### 删除与下滤

```c++
template <typename T> T PQ_ComplHeap<T>::delMax() { //删除非空完全二叉堆中优先级最高的词条
   T maxElem = _elem[0]; _elem[0] = _elem[ --_size ]; //摘除堆顶（首词条），代之以末词条
   percolateDown ( _elem, _size, 0 ); //对新堆顶实施下滤
   return maxElem; //返回此前备份的最大词条
}

//对向量前n个词条中的第i个实施下滤，i < n
template <typename T> Rank percolateDown ( T* A, Rank n, Rank i ) {
   Rank j; //i及其（至多两个）孩子中，堪为父者
   while ( i != ( j = ProperParent ( A, n, i ) ) ) //只要i非j，则
      { swap ( A[i], A[j] ); i = j; } //二者换位，并继续考查下降后的i
   return i; //返回下滤抵达的位置（亦i亦j）
}
```

### 批量建堆

```c++
//Floyd建堆算法，O(n)时间
template <typename T> void heapify ( T* A, const Rank n ) { 
   for ( Rank i = n/2 - 1; 0 <= i; i-- ) //自底而上，依次
      percolateDown ( A, n, i ); //下滤各内部节点
}
```

> 对于heapify接口，采用蛮力法（自上而下的上滤）的时间复杂度为O(nlogn)，而采用自下而上的下滤的时间复杂度为O(n)

### 堆排序

```c++
template <typename T> void Vector<T>::heapSort ( Rank lo, Rank hi ) { //0 <= lo < hi <= size
   T* A = _elem + lo; Rank n = hi - lo; heapify( A, n ); //将待排序区间建成一个完全二叉堆，O(n)
   while ( 0 < --n ) //反复地摘除最大元并归入已排序的后缀，直至堆空
      { swap( A[0], A[n] ); percolateDown( A, n, 0 ); } //堆顶与末元素对换，再下滤
}
```

## 左式堆:结构

#### :dart:引入

保持堆序性，附加新条件，使得在堆合并过程中，只需调整很少部分的节点----O（logn）

- 新条件：节点分布偏向于左侧，合并操作只限于右侧
- NPL：Null Path Length
  - npl(NULL) = 0
  - npl(x) = 1 + min( npl( x.lc ), npl( x.rc ) )
  - npl(x)=x到外部节点的最近距离
  - npl(x)=以x为根的最大满子树高度

- 示例图：![image-20220821144720078](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220821144720078.png)

#### :tada:定义

左倾：对任何内节点，都有npl(x.lc) >= npl(x.rc)

推论：对任何内节点，都有npl(x) = 1 + npl(x.rc)

- 满足左倾性的堆，即是左式堆

- 右侧链：![image-20220821145338446](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220821145338446.png)

## 左式堆:ADT

![image-20220821161431010](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20220821161431010.png)

```c++
#include "PQ/PQ.h" //引入优先级队列ADT
#include "BinTree/BinTree.h" //引入二叉树节点模板类

template <typename T>
class PQ_LeftHeap : public PQ<T>, public BinTree<T> { //基于二叉树，以左式堆形式实现的PQ
   friend class UniPrint; //演示输出使用，否则不必设置友类
public:
   PQ_LeftHeap() { } //默认构造
   PQ_LeftHeap ( T* E, int n ) //批量构造：可改进为Floyd建堆算法
   {  for ( int i = 0; i < n; i++ ) insert ( E[i] );  }
   PQ_LeftHeap( PQ_LeftHeap & A, PQ_LeftHeap & B ) { //合并构造
      _root = merge(A._root, B._root); _size = A._size + B._size;
      A._root = B._root = NULL; A._size = B._size = 0;
   }
   void insert ( T ); //按照比较器确定的优先级次序插入元素
   T getMax(); //取出优先级最高的元素
   T delMax(); //删除优先级最高的元素
}; //PQ_LeftHeap

template <typename T> T PQ_LeftHeap<T>::getMax()
{ return _root->data; } //按照此处约定，堆顶即优先级最高的词条

template <typename T> void PQ_LeftHeap<T>::insert ( T e ) {
   _root = merge( _root, new BinNode<T>( e, NULL ) ); //将e封装为左式堆，与当前左式堆合并
   _size++; //更新规模
}

template <typename T> T PQ_LeftHeap<T>::delMax() {
   BinNodePosi<T> lHeap = _root->lc; if (lHeap) lHeap->parent = NULL; //左子堆
   BinNodePosi<T> rHeap = _root->rc; if (rHeap) rHeap->parent = NULL; //右子堆
   T e = _root->data; delete _root; _size--; //删除根节点
   _root = merge ( lHeap, rHeap ); //合并原左、右子堆
   return e; //返回原根节点的数据项
}

template <typename T> //根据相对优先级确定适宜的方式，合并以a和b为根节点的两个左式堆
static BinNodePosi<T> merge ( BinNodePosi<T> a, BinNodePosi<T> b ) {
   if ( ! a ) return b; //退化情况
   if ( ! b ) return a; //退化情况
   if ( lt ( a->data, b->data ) ) swap ( a, b ); //一般情况：首先确保b不大
   ( a->rc = merge ( a->rc, b ) )->parent = a; //将a的右子堆，与b合并
   if ( !a->lc || a->lc->npl < a->rc->npl ) //若有必要
      swap ( a->lc, a->rc ); //交换a的左、右子堆，以确保右子堆的npl不大
   a->npl = a->rc ? a->rc->npl + 1 : 1; //更新a的npl
   return a; //返回合并后的堆顶
} //本算法只实现结构上的合并，堆的规模须由上层调用者负责更新
```

> 左式堆是为了有效的支持合并操作(merge)，将2个堆进行合并，不只是合并2个数组，还要维护其中的堆结构。执行合并的时间与诸右路径的长的和成正比，因为在递归调用期间对每一个被访问的节点花费的是常数工作量。因此，我们得到合并两个左式堆的时间界为O(logN)。